---
title: "Daten aufbereiten"
subtitle: "Immer noch bevor es bunt wird..."
---

```{r setup, include=FALSE, message=FALSE}
library(readxl)
library(hms)
library(tidyverse)
library(kableExtra)
```

## Ziel: Tidy data {.smaller}

[]{.down40}

> “Happy families are all alike; every unhappy family is unhappy in its own way.” — Leo Tolstoy

[]{.down40}

> “Tidy datasets are all alike, but every messy dataset is messy in its own way.” — Hadley Wickham

[]{.down40}

### Tidy data (aufgeräumte Daten)

- In jeder Spalte steht eine Variable
- In jeder Zeile steht eine Beobachtung
- In jeder Zelle steht ein Wert
- Wir haben alle Variablen, die wir benötigen

→ Nicht immer so einfach, wie es hier klingt

## Pragmatischer Ansatz

- Daten sind dann aufgeräumt, wenn das was man vorhat, einfach umzusetzen ist
- Zum Beispiel plotten

## Übersicht

[]{.down60}

Abschnitt | Aufgabe | Funktion aus dem Tidyverse
-:|-|-
1 | Funktionen hintereinander ausführen | Der pipe-Operator
2 | Variablen auswählen oder umbenennen | `select()` und `rename()`
3 | Beobachtungen auswählen | `filter()`
4 | Zeilen umsortieren | `arrange()`
5 | Variablen hinzufügen oder verändern | `mutate()`
6 | Daten zusammenfassen | `summarize()` / `group_by()`
7 | Zusammenziehen/Ausbreiten | `pivot_longer()` und `pivot_wider()`
8 | Dataframes kombinieren | `left_join()` und `cbind()`/`rbind()`
9 | Tipps und Tricks | Verschiedenes

## 1 Funktionen hintereinander ausführen mit dem Pipe-Operator `|>`

## Berechnung von verketteten Funktionen {.smaller}

$f(x) = \sin\left(\sqrt{ e^x } \right)$

[]{.down40}

### Geschachtelte Funktionen

```{r}
x <- 1.5
sin(sqrt(exp(x)))
```

→ Zuerst wird $e^x$ berechnet, dann die Wurzel gezogen und danach der Sinus ermittelt

[]{.down40}

### Mit dem Pipe-Operator `|>`

```{r}
x |> exp() |> sqrt() |> sin()
```

→ Operator `|>` fügt linke Seite als erstes Argument der Funktion rechts ein

### Berechnung von verketteten Funktionen

$f(x) = \sin\left(\sqrt{ e^x } \right)$

[]{.down40}

![](bilder/pipes.svg)

---

## Hands-On

Berechnen Sie für $x = 2.5$ die Funktion $f(x) = \sqrt{\cos\left(\sin\left(e^x\right)\right)}$ einmal ohne und einmal mit dem Pipe-Operator

```{r}
# HANDSON 3
```

## Für die folgenden Abschnitte

## Beispieldatensatz: Geschwindigkeitsmessung Unistraße {.scrollable}

```{r message = FALSE}
d_uni <- 
  read_excel("daten/unistrasse-2017.xlsx", sheet = "raw(T)", range = "B2:H20712")
kable(head(d_uni , n = 10))
```


## 2 Variablen auswählen oder umbenennen mit `select()` und `rename()`

### Wann braucht man das?

- In der Datenquelle stehen mehr Informationen als benötigt
- Die Namen der Merkmale sind in der Datei nicht gut gewählt

## Auswählen mit `select()` {.smaller}

```{r}
d_uni_1 <- d_uni |> 
  select(Datum, Fahrzeug, Geschwindigkeit) #<<
kable(head(d_uni_1 , n = 10))
```

### Funktionsweise

- Alle Merkmale angeben, die beibehalten werden sollen

## Auswählen/umbenennen mit `select()` {.smaller}

```{r}
d_uni_1 <- d_uni |> 
  select(Datum, Fahrzeug, L = `Länge (cm)`, Geschwindigkeit) #<<
kable(head(d_uni_1 , n = 10))
```

### Funktionsweise

- Alle Merkmale angeben, die beibehalten werden sollen
- Umbenennen mit `neuer_name = alter_name` 
- In nach hinten geneigte Schrägstriche (*Backticks*) setzen falls Spaltenüberschrift Leerzeichen oder ähnliches enthält

## Variablen entfernen {.scrollable}

```{r}
d_uni_1 |> 
  select(-Datum, -Fahrzeug) |> #<<
  kable()
```

### Funktionsweise

- Wird einer Variablen ein `-` vorangestellt, dann wird die Spalte entfernt
- Alle anderen Variablen werden beibehalten

## Variablen nach Muster auswählen

```{r}
d <- tibble(A_X = 1:2, B_X = 1:2, X_A = 1:2, X_B = 1:2, Datum = 1:2)
kable(d)
```

::: {layout-ncol= 2}
```{r}
d |> 
  select(starts_with("X")) |> #<<
  kable()
```

```{r}
d |> 
  select(-ends_with("X")) |> #<<
  kable()
```
:::

<br/>
[]{.up20}

### Funktionsweise

- Mit `starts_with()` und `end_with()` ein Muster für Namen festlegen
- Funktioniert auch wieder mit `-`

## Variablen umbenennen mit `rename()` {.scrollable}

```{r}
d_uni_1 |> 
  rename(V = Geschwindigkeit) |> #<<
  kable()
```

### Funktionsweise

- Variable umbenennen mit `neuer_name = alter_name`
- Alle anderen Variablen werden beibehalten

## 3 Beobachtungen auswählen mit `filter()`

### Wann braucht man das?

- Wenn einzelne Werte aussortiert werden sollen
- Wenn man sich nur für bestimmte Beobachtungen interessiert

## Beispiel: LKWs schneller als 60 km/h {.scrollable}

```{r}
d_uni_1 |> 
  filter(Fahrzeug == "LKW" & Geschwindigkeit > 60) |> #<<
  kable()
```

### Funktionsweise

- Bedingung als logischer Ausdruck mit Name der Variablen
- Mehrere Optionen mit `|` oder `&` verknüpfen

## Beispiel: Fahrzeugtyp nicht erkannt

```{r}
d_uni_1 |> 
  filter(is.na(Fahrzeug)) |> #<<
  kable()
```

## Beispiel: Zeilen mit `NA` entfernen {.scrollable}

```{r}
d_uni_1 |> 
  filter(!is.na(Fahrzeug)) |> #<<
  kable()
```

## Hands-On

Nur Beobachtungen mit LKWs und Transportern (Methode 1)

```{r}
# HANDSON 4
```

- Verwenden Sie `|`

## Hands-On

Nur Beobachtungen mit LKWs und Transportern (Methode 2)

```{r}
# HANDSON 5
```

- Verwenden Sie `%in%` und `c(...)`

## 4 Beobachtungen sortieren mit `arrange()`

### Wann braucht man das?

- Wenn man sich für die größten oder kleinsten Werte interessiert
- Um die Reihenfolge beim Plotten zu ändern, so dass bestimmte Objekte über anderen liegen

## Die langsamsten Fahrer {.scrollable}

```{r}
d_uni_1 |> 
  arrange(Geschwindigkeit) |> #<<
  kable()
```

### Anmerkungen

- Sortiert aufsteigend nach dem angegebenen Merkmal
- Schnellste Fahrer mit `desc(merkmal)` (sortiert absteigend)

## Nach mehreren Kriterien sortieren {.scrollable}

```{r}
d_uni_1 |> 
  arrange(Fahrzeug, Geschwindigkeit) |> #<<
  kable()
```

### Anmerkungen

- Zuerst nach Fahrzeugen sortieren
- Innerhalb einer Fahrzeuggruppe nach Geschwindigkeit angeordnet

## Hands-On

### Aufgaben

1. Was passiert, wenn Sie nach `-Geschwindigkeit` sortieren? 
1. Geht das für alle Merkmalstypen?

```{r}
# HANDSON 6
```

## 5 Variablen hinzufügen oder verändern mit `mutate()`

### Wann braucht man das?

- Wenn aus den vorliegenden Werten neue Werte berechnet werden sollen
- Wenn bestehende Werte verändert werden sollen (typischerweise: Datum)

## Beispiel: Geschwindigkeit gerundet {.scrollable}

```{r}
d_uni_1 |> 
  mutate(V10 = signif(Geschwindigkeit, digits = 1)) |> #<<
  kable()
```

### Funktionsweise

- `neue_variable = Ausdruck(alte_variablen)`
- Mehrere Variablen sind möglich
- Mit `signif()` auf eine signifikante Stellte gerundet

## Datum konvertieren {.smaller}

```{r}
d_uni_2 <- d_uni_1 |> 
  mutate(Datum = dmy_hms(Datum, tz = "Europe/Berlin")) #<<
kable(head(d_uni_2 , n = 10))
```

### Funktionsweise

- Nach dem Einlesen ist das Merkmal Datum eine Zeichenkette
- Alter Wert von Datum wird überschrieben
- Mit `dmy_hms()` in date-time konvertiert
- Jetzt können wir mit dem Datum arbeiten

## Uhrzeit hinzufügen

```{r}
d_uni_2 |> 
  mutate(Uhrzeit = as_hms(Datum)) |> #<<
  kable()
```

### Funktionsweise

- Mit `as_hms()` die Uhrzeit heraussuchen (`library(hms)`)

## Hands-On

Fügen Sie ein Merkmal `D15` vom Typ date-time hinzu, dass auf die beginnende Viertelstunde verweist (Hinweis: Verwenden Sie `floor_date()`)

```{r}
# HANDSON 7
```

## Alles in einem Rutsch {.smaller}

[]{.up20}

```{r}
d_unistrasse <- read_excel("daten/unistrasse-2017.xlsx",sheet="raw(T)",range="B2:H20712") |>
  select(Datum, Fahrzeug, L = `Länge (cm)`, Geschwindigkeit) |>
  filter(!is.na(Fahrzeug)) |>
  mutate(
    Datum = dmy_hms(Datum, tz = "Europe/Berlin"),
    D15 = floor_date(Datum, "15 minutes"),
    Uhrzeit = as_hms(Datum)
  )
kable(head(d_unistrasse , n = 10))
```


### Anmerkungen

- Mehrere Operationen nacheinander ausgeführt
- Lesbarkeit: Jede Operation in eine eigene Zeile
- Lange Operationen nochmal aufteilen

## Damit: Uhrzeit und Geschwindigkeit 

```{r}
ggplot(data = d_unistrasse) +
  geom_hex(mapping = aes(x = Uhrzeit, y = Geschwindigkeit)) 
```

### Mit der Uhrzeit

- Histogramm der Geschwindigkeitsverteilung über Tageszeit

## Bedingte Anweisung mit `if_else()` {.scrollable}

```{r}
d_uni_2 |>
  mutate(zu_schnell = if_else(Geschwindigkeit > 50, "Ja", "Nein")) |>
  kable()
```

### Funktionsweise von `if_else()`

- Erster Parameter ist Bedingung
- Neue Variable `zu_schnell` erhält Wert von zweitem Parameter, falls Bedingung erfüllt
- Falls Bedingung nicht erfüllt wird dritter Parameter verwendet

## 6 Zusammenfassen mit `summarize()` und `group_by()`

### Wann braucht man das?

- Wenn man wissen will, wie oft eine bestimmte Beobachtung aufgetreten ist
- Wenn Durschnittswerte oder ähnliches benötigt werden

## Nur `summarize()` {.smaller}

[]{.down60}

```{r}
d_unistrasse |> 
  summarise(n = n(), VMit = mean(Geschwindigkeit), VS = sd(Geschwindigkeit)) |> #<<
  kable()
```

[]{.down40}

### Funktionsweise

- Neue Merkmale wie bei `mutate()`
- Unterschied: Funktionen werden auf alle Werte angewendet
- Mit `n()` werden Zeilen gezählt
- Funktionen `mean()` und `sd()` wie gehabt

→ In dieser Form nicht besonders nützlich (und das können wir auch anders)

## Kombi `group_by()` und `summarize()` {.smaller}

```{r}
d_unistrasse |> 
  group_by(Fahrzeug) |> #<<
  summarise(n = n(), VMit = mean(Geschwindigkeit), VS = sd(Geschwindigkeit)) |> #<<
  kable()
```

### Funktionsweise

- Daten zunächst mit `group_by()` nach einem (oder mehreren Kriterien) gruppieren
- Danach wird mit `summarize()` zusammenfassen
  * Gruppierungsmerkmal(e) bleiben erhalten
  * Funktionen in `summarize()` werden auf jede Gruppe einzeln angewendet

→ In dieser Kombination **sehr** flexibel einsetzbar

## Beispiel: 15-Minuten Geschwindigkeit

```{r}
d_unistrasse_15m <- d_unistrasse |>
  group_by(D15) |> #<<
  summarise(VMit = mean(Geschwindigkeit)) #<<
ggplot(data = d_unistrasse_15m, mapping = aes(x = D15, y = VMit)) +
  geom_line() + geom_point() 
```

## Hands-On

### Aufgabe

- Plotten Sie die Geschwindigkeit über zwei Stunden gemittelt. Erzeugen Sie hierzu zunächst den notwendigen Dataframe.

```{r}
# HANDSON 8
```

## Effekt von `group_by()`

```{r}
d_unistrasse |> str()
```

## Effekt von `group_by()` - Attribute zur Gruppierung

```{r}
d_unistrasse |> group_by(Fahrzeug) |> str()
```

## 7 Zusammenfassen und verteilen mit `pivot_longer()` und `pivot_wider()`

### Wann braucht man das?

- Zusammenfassen: Wenn Namen von Spalten Werte sein sollten
- Verteilen: Wenn Werte Namen von Spalten sein sollten

→ Manchmal sind auch beide Darstellungen notwendig

## Breite und lange Tabellen

![](bilder/table-wide-long.svg)

- Man spricht von breiten und langen Tabellenformaten
- Englisch: *Wide and long data* 
- Aufgeräumte Daten *(tidy data)* sind meistens lang

→ Immer auch abhängig von der konkreten Situation

## Beispiel: Energieträger (Quelle: BMWi)

![](bilder/table-wide.svg)

→ Werte auf viele Spalten verteilt

### Was ist daran schlecht?

- Unpraktisch zum Plotten und Weiterverarbeiten, z.B.
  * Verbrauch von 2 Energieträgern in 2 Jahren: Summe über Rechteck

### Wir würden gerne

- Die Spalte Energieträger beibehalten
- Aus den Spaltenüberschriften 1990 bis 2017 das Merkmal Jahr machen
- Die Werte in einem Merkmal Verbrauch speichern

## Einlesen der Daten (Quelle: BMWi) {.scrollable}

```{r}
d_et<-read_excel("daten/energiedaten-gesamt-xls.xlsx", sheet="4", range="A8:AC17")
kable(d_et, h = "400px", fs = TRUE)
```

### Transformation mit `pivot_longer()`

```{r}
d_et_1 <- d_et |>
  pivot_longer(!Energieträger, names_to = "Jahr", values_to = "Verbrauch") #<<
kable(d_et_1)
```

### Funktionsweise

- Spalte(n), die beibehalten werden sollen, mit `!Name` angeben
- `names_to = Name`: Spalte für alte Spaltenüberschriften 
- `values_to = Name`: Spalte für Werte

## Beispiel vollständig

```{r}
d_energietraeger <- 
  read_excel("daten/energiedaten-gesamt-xls.xlsx", sheet="4", range="A8:AC17") |>
  pivot_longer(!Energieträger, names_to = "Jahr", values_to = "Verbrauch") |> #<<
  mutate(Jahr = as.numeric(Jahr))
ggplot(data = d_energietraeger) +
  geom_line(mapping = aes(x = Jahr, y = Verbrauch, color = Energieträger))
```


- In einem Rutsch einlesen und weiterverarbeiten
- Jahr in Zahl konvertieren mit `mutate()`

## Werte verteilen mit `pivot_wider()` {.scrollable}

```{r}
d <- d_energietraeger |>
  pivot_wider(names_from = Energieträger, values_from = Verbrauch)
kable(d)
```

### Funktionsweise

- `names_from = Name`: Spalte mit neuen Spaltenüberschriften
- `values_from = Name`: Spalte mit Werten, die verteilt werden sollen

→ Damit transponierte der ursprünglichen Tabelle

## Hands-On 1/2 {.scrollable}

```{r}
d_messwerte <- 
  tibble(messung = 1:20, richtung = "x", wert = 30:11) |> 
  rbind(tibble(messung = 1:20, richtung = "y", wert = 30:11 + 2 * rnorm(20)))
kable(d_messwerte)
```

### Aufgabe

- Erstellen Sie einen Streuplot der y-Werte über die x-Werte
- Erzeugen Sie hierzu zunächst mit `pivot_wider()` einen neuen Dataframe

## Hands-On 2/2

```{r}
# HANDSON 9
```

## 8 Tabellen verknüpfen und aneinanderhängen mit `left_join()` und `rbind()`/`cbind()`

### Wann braucht man das?

- Wenn in einer Spalte Kürzel stehen, die in einem anderen Dataframe hinterlegt sind
- Wenn zwei Dataframes aneinandergehängt werden sollen

## Tabellen über einen Schlüssel miteinander verknüpfen

[]{.down60}

![](bilder/mitarbeiter-beispiel.svg)

[]{.down40}

### Grundprinzip

- Tabellen sind über gemeinsames Merkmal (gelb) miteinander verknüpft
- Neue Tabelle mit Werten zu Verknüpfungsmerkmal
- Schlüssel in zweiter Tabelle nicht vorhanden: NAs einsetzen
- Schlüssel müssen in zweiter Tabelle eindeutig sein!

## Umsetzung in R mit `left_join()`

```{r, message = FALSE}
d_mitarbeiter <- read_excel("daten/mitarbeiter-beispiel.xlsx", range = "B2:E7")
kable(d_mitarbeiter)
```


## Umsetzung in R mit `left_join()`

```{r, message = FALSE}
d_abteilungen <- read_excel("daten/mitarbeiter-beispiel.xlsx", range = "G2:I7")
kable(d_abteilungen)
```

## Umsetzung in R mit `left_join()`

```{r, message = FALSE}
d_mitarbeiter_1 <- d_mitarbeiter |> left_join(d_abteilungen) #<<
kable(d_mitarbeiter_1)
```


### Funktionsweise

- Dataframes müssen ein Merkmal gemeinsam haben
- Gegebenenfalls Merkmal mit `rename()` umbenennen (wie `select()`)
- Left in `left_join()`: Alle Zeilen aus linker Tabelle werden übernommen
- Andere Varianten (`inner_join()` etc.) für Spezialfälle

## Anwendung: Kodierte Werte 1/4

[]{.up20}

### Fiktive Unfalldaten

![](bilder/kodierte-werte.svg)

### Situation

- In den Rohdaten sind Codes eingetragen und nicht Werte 
- Warum macht man das?
  * Arbeit sparen wenn Werte von Hand eingetragen werden
  * Speicherplatz sparen bei umfangreichen Tabellen
- Für statistische Auswertung: Dataframe mit Werten

## Anwendung: Kodierte Werte 2/4

### Unfalldaten

```{r}
d_ud <- read_excel("daten/beispiel-kodierung.xlsx", range="B2:D5")
kable(d_ud)
```

## Anwendung: Kodierte Werte 3/4 {.smaller}

### Kodierung der Orte und Unfallarten

```{r}
d_ud_k1 <- read_excel("daten/beispiel-kodierung.xlsx", range="F2:G5")
kable(d_ud_k1)
```

```{r}
d_ud_k2 <- read_excel("daten/beispiel-kodierung.xlsx", range="I2:J5")
kable(d_ud_k2)
```

## Anwendung: Kodierte Werte 4/4

```{r, message = FALSE}
d_ud |>
  left_join(d_ud_k1) |>
  left_join(d_ud_k2) |>
  select(-ends_with("_code")) |>
  kable()
```

### Vorgehensweise

- Unfalldaten mit beiden Kodierungstabellen verknüpfen
- Spalten mit den Codes löschen

## Datenframes aneinander hängen {.smaller}

```{r}
d1 <- tibble(X = c("A", "B"), Y = c(1, 2))
d2 <- tibble(X = "C", Y = 3)
d3 <- tibble(Z = c(1.7, 2.9))
```

[]{.up10}

::: {layout-ncol=2}
```{r}
d1 |> cbind(d3) |> kable()
```

```{r}
d1 |> rbind(d2) |> kable()
```

:::

### Funktionsweise 

- Mit `rbind()` Dataframes hintereinander *(row-bind)*  
  → Merkmale müssen gleich sein!
- Mit `cbind()` Dataframes nebeneinander *(column-bind)*  
  → Anzahl der Beobachtungen müssen gleich sein!

## 9 Verschiedenes

### Tipps und Tricks

## Werte durch NAs ersetzen 1/4

![](bilder/fehlwerte-niederschlag.svg)

### Niederschlagsdaten vom Deutschen Wetterdienst

- Ein Wert von -999 kennzeichnet eine fehlende Beobachtung
- In R sollte das ein `NA` sein

## Werte durch NAs ersetzen 2/4 {.scrollable}

```{r}
d_ns <- read.csv(
  "daten/produkt_nieder_monat_18910101_20171231_00555.txt", 
  sep=";", dec="."
)
kable(head(d_ns , n = 10))
```

## Werte durch NAs ersetzen 3/4 {.scrollable}

```{r}
kable(d_ns, h = "300px")
```

### Dataframe der Niederschlagsaufzeichnung

- Wert -999 in fast allen Spalten

## Werte durch NAs ersetzen 4/4 {.scrollable}

```{r}
d_ns |> 
  mutate(MO_NSH = na_if(MO_NSH, -999)) |> #<<
  kable(h = "300px")
```

### Vorgehensweise

- Mit `na_if(Y, x)` alle Werte `x` in Spalte `Y` durch `NA` ersetzen

## Werte auftrennen 1/2

```{r}
d_z <- tibble(X = c("10, A, 4.3", "11, X, 1.9", "2, R, 3.3"))
kable(d_z)
```

### Problem

- In dem Dataframe stehen in jeder Zeile drei Werte

## Werte auftrennen 2/2

```{r}
d_z |> 
  separate(col=X, into=c("Wert", "Name", "Laenge"), sep=",") |> #<<
  kable()
```

### Funktion `separate()` verteilt Werte auf Spalten

- Spalte mit Ausgangswerten angeben mit `col`
- Neue Spalten in Parameter `into` (Namen als Zeichenkette)
- Mit `sep` angeben, welches Zeichen die Einträge trennt

## Gruppiertes `mutate()` 1/2 {.scrollable}


```{r}
kable(d_energietraeger)
```

### Problem

- In der Tabelle soll eine Spalte mit dem anteiligen Energieverbrauch erzeugt werden
- Wert: 100 x Energieverbrauch / Gesamtverbrauch im Jahr

## Gruppiertes `mutate()` 2/2 {.scrollable}

```{r}
d_energietraeger |>
  group_by(Jahr) |> #<<
  mutate(Anteil = 100 * Verbrauch / sum(Verbrauch)) |> #<<
  kable()
```

### Lösung

- Daten nach Jahren gruppieren
- Dann berechnet `sum()` die Summe in einer Gruppe
- Ergebnis auf jeden Fall kontrollieren (hier: Vergleich mit BMWi-Tabelle)

## Gruppiertes `filter()` 1/2 {.scrollable}

```{r}
kable(d_unistrasse)
```

### Problem

- Gesucht ist das schnellste Fahrzeug aus jeder Gruppe

## Gruppiertes `filter()` 2/2 {.scrollable}

```{r}
d_unistrasse |>
  group_by(Fahrzeug) |> #<<
  filter(Geschwindigkeit == max(Geschwindigkeit)) |> #<<
  kable()
```

### Lösung

- Nach Fahrzeugtyp gruppieren
- Mit `max(Geschwindigkeit)` die schnellste Messung pro Gruppe heraussuchen
- Beobachtung mit der größten Geschwindigkeit herausfiltern

## Werte ersetzen mit `recode()` 1/2 {.scrollable}

```{r}
kable(d_et, h = "350px", fs = TRUE)
```

### Problem

- Bezeichnungen teilweise zu lang
- Verweise auf Erläuterungen für statistische Auswertung nicht hilfreich

## Werte ersetzen mit `recode()` 2/2 {.scrollable}

```{r}
d_et |> mutate(
    Energieträger = recode(
      Energieträger, 
      "Erdgas, Erdölgas" = "Gas",
      "Wasser- und Windkraft 1) 3)" = "Wasser/Wind",
      "andere Erneuerbare 2)" = "andere Erneuerbare"
    )
  ) |>
  kable(h = "200px", fs = TRUE)
```


### Funktionsweise

- Spalte und Ersetzungen angeben
